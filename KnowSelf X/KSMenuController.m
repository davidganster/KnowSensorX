//
//  KSMenu.m
//  KnowSensor X
//
//  Created by David Ganster on 19/11/13.
//  Copyright (c) 2013 David Ganster. All rights reserved.
//

#import "KSMenuController.h"
#import "KSProject.h"
#import "KSActivity.h"
#import "KSSensorController.h"
#import "KSUserInfo.h"
#import "KSAppDelegate.h"
#import "KSMainWindowController.h"
#import "KSRecordActivityWindowController.h"


@interface KSMenuController ()

/// The menu item that shows the current project/activity.
/// Will be updated when `currentProject` or `currentActivity` are set.
@property (weak) IBOutlet NSMenuItem *currentActivityMenuItem;

/// The menu item that can stop the currently recording activity.
/// Needs an outlet because its enabled/disabled state will change during runtime.
/// @note Since setting enabled/disabled on an NSMenuItem
@property (weak) IBOutlet NSMenuItem *stopRecordingActivityMenuItem;

/// Re-declaring the menu object as readwrite - we do want a setter internally.
@property (readwrite, strong) IBOutlet NSMenu *menu;

/// The menu item that manages the project list submenu.
@property (weak) IBOutlet NSMenuItem *projectListMenuItem;

@end

@implementation KSMenuController

/**
 *  Designated initializer.
 *  Fully initializes a KSMenuController and tries to load its accompanying nib file.
 *
 *  @return The initialized KSMenuController object.
 */
- (id)init
{
    self = [super init];
    if(self) {
        NSArray *nibElements;
        NSNib *nib = [[NSNib alloc] initWithNibNamed:@"KSMenu" bundle:nil];
        BOOL couldLoadNib = [nib instantiateWithOwner:self topLevelObjects:&nibElements];
        if(couldLoadNib) {
            for (id item in nibElements) {
                if([item isKindOfClass:[NSMenu class]]) {
                    self.menu = item;
                    self.currentActivity = nil;
                    break;
                }
            }
            
            [[NSNotificationCenter defaultCenter] addObserver:self
                                                     selector:@selector(serverUp:)
                                                         name:kKSNotificationKeyServerReachable
                                                       object:nil];

        } else {
            // no point in doing anything else if we could not even load the menu...
            return nil;
        }
    }
    return self;
}

/**
 *  Internal method.
 *  Used to react to `serverReachable` notifications.
 *
 *  @param notification The notification generated by the KSAPIClient.
 */
- (void)serverUp:(NSNotification *)notification
{
    [[KSProjectController sharedProjectController] addObserverForProjectRelatedEvents:self];
    [[KSProjectController sharedProjectController] startUpdatingProjectListWithTimeBetweenPolls:kKSProjectControllerPollInterval];
}

- (void)projectController:(KSProjectController *)controller projectListChangedWithAddedProjects:(NSArray *)addedObjects
         deletedProjects:(NSArray *)deletedProjects
{
//    LogMessage(kKSLogTagOther, kKSLogLevelInfo, @"Project list changed!");
    
    // We don't really need to keep track of the changes here, since we just replace the full project list.
    [self setProjectList:controller.currentProjectList];
}

- (void)projectController:(KSProjectController *)controller activeActivityChangedToActivity:(KSActivity *)activity
{
    [self setCurrentActivity:activity];
}

- (void)setCurrentActivity:(KSActivity *)currentActivity
{
    _currentActivity = currentActivity;
    
    [self.stopRecordingActivityMenuItem setAction:(_currentActivity ) ? @selector(stopRecordingActiveActivity:) : nil];
    [self.menu update];
    
    // set the current project in the project list ton have the tick
    for (NSMenuItem *menuItem in self.projectListMenuItem.submenu.itemArray) {
        KSProject *project = [menuItem representedObject];
        if(project == _currentActivity.project && project != nil) {
            [menuItem setState:NSOnState];
        } else {
            [menuItem setState:NSOffState];
        }
    }
    
    [self updateCurrentProjectItem];
}

/**
 *  Internal method.
 *  Updates the UI with the current project and activity.
 */
- (void)updateCurrentProjectItem
{
    NSString *newTitle = @"No active project/activity.";
    if(self.currentActivity) {
        newTitle = [self.currentActivity.projectName stringByAppendingString:[@"/" stringByAppendingString:self.currentActivity.name]];
    }
    self.currentActivityMenuItem.title = newTitle;
}

// projectList contains only valid objects, no deleted ones.
- (void)setProjectList:(NSArray *)projectList
{
    if([self.projectList isEqualToArray:projectList])
        return;
    
    if(!self.projectList && projectList) {
        // first time with data
        self.projectListMenuItem.submenu = [[NSMenu alloc] init];
    }
    
    NSEnumerator *reverseEnumerator = [projectList reverseObjectEnumerator];
    KSProject *project = nil;
    while((project = [reverseEnumerator nextObject])) {

        NSMenuItem *projectMenuItem = [[NSMenuItem alloc] initWithTitle:project.name
                                                                 action:@selector(projectClicked:)
                                                          keyEquivalent:@""];
        [projectMenuItem setTarget:self];
        [projectMenuItem setRepresentedObject:project];

        if(project == self.currentActivity.project) {
            [projectMenuItem setState:NSOnState];
        }
        
        [self.projectListMenuItem.submenu insertItem:projectMenuItem atIndex:0];
    }
    
    [self.menu update];
}

/**
 *  Internal method, triggered by the `Stop recording` menu item.
 *  Tells the KSProjectController to stop recording the current activity, without checking
 *  for success.
 *
 *  @param sender The button that generated the event. Unused.
 */
- (IBAction)stopRecordingActiveActivity:(id)sender
{
    [[KSProjectController sharedProjectController] stopRecordingCurrentActivitySuccess:^{
        // nothing to do?
    } failure:^(NSError *error) {
        // nothing to do?
    }];
}

/**
 *  Internal method, triggered by the `Start recording activity` menu item.
 *  Shows the 'record new activity' window.
 *
 *  @param sender The button that generated the event. Unused.
 */
- (IBAction)recordNewActivity:(id)sender
{
    // show 'record new activity' popup
    [self showRecordActivityWindowWithProject:nil
                                     activity:nil];
}

/**
 *  Internal method, triggered by any of the projects in the project list.
 *  Shows the 'record new activity' window with the clicked project pre-selected.
 *
 *  @param sender The menu item that generated the event. Used to figure out which project has been clicked.
 */
- (void)projectClicked:(NSMenuItem *)sender
{
    [self showRecordActivityWindowWithProject:sender.representedObject
                                     activity:nil];
}

/**
 *  Internal method, triggered by clicking the 'Show Preferences' menu item.
 *  Shows the 'Settings' window.
 *
 *  @param sender The menu item that generated the event. Unused.
 */
- (IBAction)showPreferencePane:(id)sender
{
    [NSApp activateIgnoringOtherApps:YES];
    
    KSAppDelegate *delegate = [[NSApplication sharedApplication] delegate];
    KSMainWindowController *controller = delegate.mainWindowController;
    
    [controller showWindow:controller.window];
}

/**
 *  Internal method, triggered by the 'Show web app' menu item.
 *  Opens the default browser to the current server address.
 *
 *  @param sender The menu item that generated the event. Unused.
 */
- (IBAction)showWebApp:(id)sender
{
    NSURL *url = [NSURL URLWithString:[[KSUserInfo sharedUserInfo] serverAddress]];
    [[NSWorkspace sharedWorkspace] openURL:url];
}

/**
 *  Internal method, triggered by the 'Private mode' menu item.
 *  Toggles the recording of events.
 *
 *  @param sender The button that generated the event. Used to decide if the recording of events should be stopped or started.
 */
- (IBAction)togglePrivateMode:(NSMenuItem *)sender
{
    if(sender.state == NSOffState) {
        [sender setState:NSOnState];
        [[KSSensorController sharedSensorController] stopRecordingEventsFinished:nil];
    } else if(sender.state == NSOnState) {
        [sender setState:NSOffState];
        [[KSSensorController sharedSensorController] startRecordingEvents];
    } else {
        LogMessage(kKSLogTagOther, kKSLogLevelError, @"The privateMode button is in mixed state?!");
    }
}

/**
 *  Internal method, triggered by the 'Write to diary' menu item.
 *  Opens the default browser to the 'show observations' page.
 *
 *  @param sender The menu item that generated the event. Unused.
 */
- (IBAction)writeToDiary:(id)sender
{
    NSString *baseUrl = [[KSUserInfo sharedUserInfo] serverAddress];
    NSString *fullUrl = [baseUrl stringByAppendingString:kKSServerShowObservationsURL];
    NSURL *url = [NSURL URLWithString:fullUrl];
    [[NSWorkspace sharedWorkspace] openURL:url];
}

/**
 *  Internal method, triggered by the 'Quit KnowSensor X' menu item.
 *
 *  @param sender The menu item that generated the event. Unused.
 */
- (IBAction)quit:(id)sender
{
    [[NSApplication sharedApplication] terminate:self];
}

#pragma mark - Helper
/**
 *  Internal helper method for showing the 'Record new activity' window for a given activity and project.
 *
 *  @param project  The project that will be fed to the KSRecordActivityWindowController.
 *  @param activity The activity that will be fed to the KSRecordActivityWindowController.
 */
- (void)showRecordActivityWindowWithProject:(KSProject *) project
                                   activity:(KSActivity *)activity
{
    KSRecordActivityWindowController *controller = [[KSRecordActivityWindowController alloc] initWithProject:project
                                                                                                    activity:activity];
    [NSApp activateIgnoringOtherApps:YES];
    [controller showWindow:controller.window];
}

@end
